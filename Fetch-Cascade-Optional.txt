1. FETCH: Quando uma QUERY é realizada com o auxílio do Hibernate, ele utiliza estratégias de busca adequando-se para cada situação, sendo capaz do desenvolvedor alterar essa propriedade buscando maior desempenho na aplicação. Se temos um CarrinhoDeCompras e Itens com um relacionamento @OneToMany, provavelmente temos uma coleção de Itens dentro de CarrinhoDeCompras. Há duas tipos de FETCH, o EAGER e o LAZY. Pensando no exemplo anterior, quando a gente carregar o CarrinhoDeCompras, usando o método LAZY, os itens desse carrinho não serão carregados até que de fato fazemos essa consulta, diferente do EAGER, que logo após carregarmos o CarrinhoDeCompras, todos os itens associados seriam carregados juntos. Isso pode ser ou não benéfico para uma aplicação, em alguns casos precisamos de informações específicas dos itens sempre que carregarmos o Carrinho, em outros carregaremos informações desnecessárias prejudicando o desempenho de nossa API. É válido consultar e estudar cada caso, mas normalmente é usado o FetchType.LAZY para tudo, e usar uma outra estratégia do Hibernate, a estratégia do Join Fetch em um Select específico, quando é necessário usar alguma informação que não foi carregada anteriormente, deixando a aplicação mais "esperta" e otimizada.

2. CASCADE: O CASCADE é uma opção ao realizar o mapeamento de entidades num banco de dados, onde é possível atualizar as informações de entidades relacionadas com a entidade que foi alterada automaticamente. Há 6 opções para o CASCADE: 
	Persist -> Propaga operações de persistência num banco de dados, como ao salvar um Objeto Pai Cliente, também será salvo as informações de um Objeto Filho Telefone que estão associados ao Cliente
	Merge -> Propaga as operações de atualização, quando não há nem adição nem remoção de um novo Objeto Pai, mas sim atualizações, as informações do Objeto Filho associadas também serão atualizadas 
	Remove -> Propaga as operações de remoção, quando o objeto Pai é removido do banco de dados, todos os objetos Filhos associados também serão removidos.
	Refresh -> Propaga as operações de recarregamento, ou seja, quando a entidade do objeto Pai sofre alguma atualização, toda a entidade Filha associada será recarregada do banco de dados
	All -> O mais usado, corresponde a todas as operações (Persist, Merge, Remove e Refresh)
Como em qualquer propriedade de mapeamento de entidades, todas as opções são válidas e qualquer uma pode ser usada a depender do contexto, como no caso de um CarrinhoDeCompras com diversos Itens, se quisermos excluir um Item do carrinho, também queremos remover a NotaFiscal que esse item possui, ou se adicionarmos mais um item, então queremos que a NotaFiscal também seja adiciona na sua respectiva entidade, nesse caso o .All seria o ideal. 

3. OPTIONAL: A propriedade OPTIONAL diz respeito da obrigatoriedade de existência de um determinado objeto que pertence a relação em um mapeamento de entidades. Por padrão, o hibernate coloca essa configuração como TRUE, ou seja, todo objeto mesmo que relacionado com o objeto que estamos instanciando e persistindo, não deve necessariamente existir, caso não exista ele será passado como NULL. Ainda usando exemplo do CarrinhoDeCompras e os itens, podemos criar um Carrinho vazio, mas não podemos comprar um Item sem adicionar ao carrinho de compras, então na visão do Carrinho, o item possui o optional como true, na visão do Item o carrinho possui optional como false, forçando que cada item criado pertença a um carrinho existente.
